#!/usr/bin/env node
"use strict";
var argv = require('optimist')
    .usage('Convert a ProtoBuf.js JSON description in TypeScript definitions.\nUsage: $0')
    .demand('f')
    .alias('f', 'file')
    .describe('f', 'The JSON file')
    .demand('o')
    .alias('o', 'out')
    .describe('o', 'The output file')
    .default('o', './torename.d.ts')
    .argv;

var StreamWriter = (function () {
    function StreamWriter() {
        this.lines = [];
        this.ident = 0;
    }
    StreamWriter.prototype.write = function (text) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.lines.length == 0)
            this.lines.push("");
        this.lines[this.lines.length - 1] = this.lines[this.lines.length - 1] + text.replace(/\{(\d+)\}/g, function (m, i) {
                return args[i];
            });
    };
    StreamWriter.prototype.writeln = function (text) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var p = "";
        for (var i = 0; i < this.ident; i++)
            p += "	";
        this.lines.push(p + text.replace(/\{(\d+)\}/g, function (m, i) {
                return args[i];
            }));
    };
    StreamWriter.prototype.save = function (fn) {
        console.log(this.lines.join("\r\n"));
        fs.writeFileSync(fn, this.lines.join("\r\n"), { encoding: "utf-8" });
    };
    return StreamWriter;
})();

// Import in typescript and commondjs style
//var ProtoBuf = require("protobufjs");
var DustJS = require("dustjs-helpers");
var fs = require("fs");
// Keep line breaks
DustJS.optimizers.format = function (ctx, node) { return node; };
// Create view filters
DustJS.filters["firstLetterInUpperCase"] = function (value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
};
DustJS.filters["firstLetterInLowerCase"] = function (value) {
    return value.charAt(0).toLowerCase() + value.slice(1);
};
DustJS.filters["camelCase"] = function (value) {
    return value.replace(/(_[a-zA-Z])/g, function (match) { return match[1].toUpperCase(); });
};
DustJS.filters["convertType"] = function (value) {
    switch (value.toLowerCase()) {
        case 'string':
            return 'string';
        case 'bool':
            return 'boolean';
        case 'bytes':
            return 'Uint8Array';
        case 'double':
        case 'float':
        case 'int32':
        case 'uint32':
        case 'sint32':
        case 'fixed32':
        case 'sfixed32':
            return "number";
        case 'int64':
        case 'uint64':
        case 'sint64':
        case 'fixed64':
        case 'sfixed64':
            return "number";
    }
    // By default, it's a message identifier
    return value;
};
DustJS.filters["optionalFieldDeclaration"] = function (value) { return value == "optional" ? "?" : ""; };
DustJS.filters["repeatedType"] = function (value) { return value == "repeated" ? "[]" : ""; };
function loadDustTemplate(name) {
    var template = fs.readFileSync(__dirname + "/templates/" + name + ".dust", "UTF8").toString(), compiledTemplate = DustJS.compile(template, name);
    DustJS.loadSource(compiledTemplate);
}
// Generate the names for the model, the types, and the interfaces
function generateNames(model, prefix, name) {
    if (name === void 0) { name = ""; }
    model.fullPackageName = prefix + (name != "." ? name : "");
    // Copies the settings (I'm lazy)
    model.properties = argv.properties;
    model.camelCaseProperties = argv.camelCaseProperties;
    model.camelCaseGetSet = argv.camelCaseGetSet;
    model.underscoreGetSet = argv.underscoreGetSet;
    var newDefinitions = {};
    // Generate names for messages
    // Recursive call for all messages
    var key;
    for (key in model.messages) {
        var message = model.messages[key];
        newDefinitions[message.name] = "";
        generateNames(message, model.fullPackageName, "." + (model.name ? model.name : ""));
    }
    // Generate names for enums
    for (key in model.enums) {
        var currentEnum = model.enums[key];
        newDefinitions[currentEnum.name] = "";
        currentEnum.fullPackageName = model.fullPackageName + (model.name ? "." + model.name : "");
    }
    // For fields of types which are defined in the same message,
    // update the field type in consequence
    for (key in model.fields) {
        var field = model.fields[key];
        if (typeof newDefinitions[field.type] !== "undefined") {
            field.type = model.name + "." + field.type;
        }
    }
    model.oneofsArray = [];
    for (key in model.oneofs) {
        var oneof = model.oneofs[key];
        model.oneofsArray.push({ name: key, value: oneof });
    }
    // Add the new definitions in the model for generate builders
    var definitions = [];
    for (key in newDefinitions) {
        definitions.push({ name: key, type: ((model.name ? (model.name + ".") : "") + key) + newDefinitions[key] });
    }
    model.definitions = definitions;
}
// Load dust templates
loadDustTemplate("module");
loadDustTemplate("interface");
loadDustTemplate("enum");
loadDustTemplate("builder");
// Load the json file
var model = JSON.parse(fs.readFileSync(argv.file).toString());
// If a packagename isn't present, use a default package name
if (!model.package) {
    model.package = "Proto2TypeScript";
}
// Generates the names of the model
generateNames(model, model.package);

var extensionMap = {};
var myMessageMap = {};

var sw = new StreamWriter();

var moduleName = "VGFishProto";

sw.writeln("declare module jspb {");
sw.writeln("export interface ExtensionFieldBinaryInfo {");
sw.ident++;
sw.writeln("fieldInfo: jspb.ExtensionFieldInfo;");
sw.writeln("binaryReaderFn: Function;");
sw.writeln("binaryWriterFn: Function;");
sw.writeln("binaryMessageSerializeFn: Function;");
sw.writeln("binaryMessageDeserializeFn: Function;");
sw.writeln("isPacked: boolean;");
sw.ident--;
sw.writeln("}");
sw.writeln("export interface ExtensionFieldInfo {");
sw.ident++;
sw.writeln("fieldIndex: number;");
sw.writeln("fieldName: string;");
sw.writeln("ctor: any;");
sw.writeln("ObjectFn: Function;");
sw.writeln("isRepeated: boolean;");
sw.ident--;
sw.writeln("}");
sw.writeln("export interface Message {");
sw.writeln("}");
sw.writeln("}");
sw.writeln("declare module proto." + moduleName + "{");
sw.ident++;

var enums = model.enums;
if (enums) {
    // export const enum Type {
    //     REQUEST = 1,
    //         RESPONSE = 2,
    // }
    for (var i = 0; i < enums.length; i++) {
        var e = enums[i];
        sw.writeln("export const enum " + e.name + " {");
        sw.ident++;

        for (var q = 0; q < e.values.length; q++) {
            var v = e.values[q];
            sw.writeln(v.name + " = " + v.id + ",");
        }

        sw.ident--;
        sw.writeln("}");
    }
}
sw.ident--;
sw.writeln("}");

var messages = model.messages;

// 导出message
for (var i = 0; i < messages.length; i++) {
    var msg = messages[i];

    function  dumpMsg(m) {


        if (m.ref) {
            sw.writeln("declare module proto." + m.fullPackageName + " {");
            sw.ident++;

            sw.writeln("export interface " + m.ref + " {");
            sw.ident++;

            sw.writeln("getExtension(a: jspb.ExtensionFieldInfo);");
            sw.writeln("setExtension(a: jspb.ExtensionFieldInfo, b: jspb.Message);");

            sw.ident--;
            sw.writeln("}");

            sw.ident--;
            sw.writeln("}");

            sw.writeln("declare module proto." + m.fullPackageName + " {");
            sw.ident++;

            {
                var fields = m.fields;
                if (fields) {
                    for (var i1 = 0; i1 < fields.length; i1++) {
                        var f = fields[i1];
                        sw.writeln("export var " + f.name.toLowerCase() + ": jspb.ExtensionFieldInfo;");
                        f["__Parent"] = m;
                        extensionMap[(m.fullPackageName ? (m.fullPackageName + ".") : "") + DustJS.filters["convertType"](f.type)] = f;
                    }
                }
            }

            sw.ident--;
            sw.writeln("}");

            {
                var enums = m.enums;
                if (enums) {

                    for (var k = 0; k < enums.length; k++) {
                        var e = enums[k];
                        sw.writeln("declare module proto." + e.fullPackageName + " {");
                        sw.ident++;
                        sw.writeln("export const enum " + e.name + " {");
                        sw.ident++;

                        for (var q = 0; q < e.values.length; q++) {
                            var v = e.values[q];
                            sw.writeln(v.name + " = " + v.id + ",");
                        }

                        sw.ident--;
                        sw.writeln("}");
                        sw.ident--;
                        sw.writeln("}");
                    }
                }
            }
        } else {
            // keep the message
            myMessageMap[m.fullPackageName + m.name] = m;

            sw.writeln("declare module proto." + m.fullPackageName + " {");
            sw.ident++;

            sw.writeln("export class " + m.name + " {");
            sw.ident++;

            sw.writeln("constructor(data?: any[]);");

            if (m.extensions) {
                sw.writeln("static extensions: {};");
                sw.writeln("static extensionsBinary: {};");
            }

            sw.writeln("serializeBinary: () => any;");
            sw.writeln("static deserializeBinary: (data) => any;");

            function nameToLowcase(n) {
                n = n.toLowerCase();
                var f = n.substring(0, 1).toUpperCase();
                n = f + n.substring(1, n.length);
                return n;
            }

            {
                var fields = m.fields;
                if (fields) {
                    // export const enum Type {
                    //     REQUEST = 1,
                    //         RESPONSE = 2,
                    // }
                    for (var i1 = 0; i1 < fields.length; i1++) {
                        var f = fields[i1];
                        if (f.rule == "repeated") {
                            sw.writeln("get" + nameToLowcase(f.name) + "List: () => " + DustJS.filters["convertType"](f.type) + "[];");
                            sw.writeln("set" + nameToLowcase(f.name) + "List: (value: " + DustJS.filters["convertType"](f.type) + "[]) => void;");
                        } else {
                            sw.writeln("get" + nameToLowcase(f.name) + ": () => " + DustJS.filters["convertType"](f.type) + ";");
                            sw.writeln("set" + nameToLowcase(f.name) + ": (value: " + DustJS.filters["convertType"](f.type) + ") => void;");
                        }
                    }
                }
            }

            sw.ident--;
            sw.writeln("}");

            sw.ident--;
            sw.writeln("}");

            {
                var enums = m.enums;
                if (enums) {

                    for (var k = 0; k < enums.length; k++) {
                        var e = enums[k];
                        sw.writeln("declare module proto." + e.fullPackageName + " {");
                        sw.ident++;
                        sw.writeln("export const enum " + e.name + " {");
                        sw.ident++;

                        for (var q = 0; q < e.values.length; q++) {
                            var v = e.values[q];
                            sw.writeln(v.name + " = " + v.id + ",");
                        }

                        sw.ident--;
                        sw.writeln("}");
                        sw.ident--;
                        sw.writeln("}");
                    }
                }
            }
        }
    }

    dumpMsg(msg);

    if (msg.messages && msg.messages.length > 0) {
        for (var kk = 0; kk < msg.messages.length; kk++) {
            dumpMsg(msg.messages[kk]);
        }
    }
}

sw.save(argv.out);

sw = new StreamWriter();

sw.writeln("import VGFishProto = proto.VGFishProto;");

var keys = Object.keys(myMessageMap);
for (var k in keys) {

    var m = myMessageMap[keys[k]];

    var params = "";
    if (m.fields) {
        m.fields.sort(function (a, b) {
            return a.rule == "optional" ? 1 : -1;
        });
    }
    var filedNames = [];
    for (var i = 0; i < m.fields.length; i++) {
        var f = m.fields[i];
        var tt = DustJS.filters["convertType"](f.type);
        if (tt=="string"){

        } else if (tt == "number") {

        } else if (tt == "Uint8Array" ){

        } else if (tt == "boolean" ){

        } else {
            tt = m.fullPackageName + "." + tt;
        }
        if (f.rule == "optional") {
            params += f.name + "?: " + tt;
        } else {
            params += f.name + ": "  + tt;
        }
        if (i != m.fields.length - 1) {
            params += ","
        }
        filedNames.push(f.name);
    }

    sw.writeln("function Pack" +  m.fullPackageName.replace(".", "_") + "_" + m.name + " (" + params + ") {");
    sw.ident++;

    var extName = (m.fullPackageName ? (m.fullPackageName + ".") : "") + m.name;
    var isExten = extensionMap[extName];
    if (isExten) {
        var p = isExten["__Parent"];
        sw.writeln("var pr = Pack" + p.fullPackageName + "_" + p.ref + "();");
        sw.writeln("pr.setExtension(proto." + m.fullPackageName + "." + m.name.toLowerCase() + ", [" + filedNames.join() + "]);");
        sw.writeln("return pr;");
    } else {
        sw.writeln("var r = new " + m.fullPackageName + "." + m.name + "([" + filedNames.join() + "]);");
        sw.writeln("return r;");
    }

    sw.ident--;
    sw.writeln("}");
}

sw.save("./pack.ts");

